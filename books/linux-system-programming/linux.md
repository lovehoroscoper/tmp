### Chapter 3: I/Oのバッファリング

- すべてのディスクI/Oはブロックにもとづいて処理されるので、ブロックサイズでアラインメントされたI/Oのほうがパフォーマンス的に有利
- サイズの小さなI/Oを多数発行する必要のあるI/O→ユーザバッファリングI/O
	- カーネル側での遅延書き込み、先読みによる内部バッファリングと同様に、パフォーマンス向上を狙ったもの
- ブロックサイズ単位のコピーのほうが、たとえシステムコールの回数が増えたとしても高速になる
	- ブロックサイズ＝カーネルとハードウェアのやり取りの単位そのものだから、余計な処理を発生させなくて済むため
	- アラインメントの範囲内でできるだけシステムコールの回数を減らすためには、大きめのブロックサイズ整数倍を使用する
- ただし、アプリケーション自体の処理単位がブロックサイズの整数倍、なんてことはまぁ無い話（1行とか、せいぜいそんなレベル）
	- というわけで、データは一度プロセス空間のバッファに蓄えられる
	- バッファサイズに達したところで、一度に書き出し
	- 読み込みも、バッファサイズ分いっきに読んだ上で、アプリには磯の一部を渡す
	- ブロックサイズ整数倍のバッファサイズを設定して読み書きを行ってあげればいい
- そんなユーザ空間のバッファリングを提供するものがStandard I/O
	- CはI/Oを処理する機能を言語自体には本来包括していない。ユーザによって開発されたI/Oの機能セットがstdio
	- 1. StandardIOを使うか、
	- 2. 自作のユーザ空間バッファリングを使うか、
	- 3. そもそもユーザ空間ではバッファリングしないシステムコールを使用するか、
	- これはアプリケーションの要求と動作を鑑みて開発者が判断すべき
- ファイルポインタをファイルディスクリプタに対応付けて、ユーザ側はファイルポインタを使用
	- オープンしたファイル：ストリーム（入力ストリーム＆出力ストリーム）
		- stream = fopen
- open()済ファイルディスクリプタのストリームへの変換: stream = fdopen(fd, "r")
	- streamはfdと対応づいている（参照している）だけなので、streamを閉じればfdも閉じる
- fclose(stream), floseall() // 標準入・出・エラーも閉じちゃう
- fgetc()
- ungetc(): 次の文字の先読み、POSIXでは確実に戻せるのは1文字のみ、Linuxはいくらでも戻せて、戻した順番の逆順で次は読まれる
	- つまり、一度読んだ文字を「読まなかったことにする」
	- 式をパースするときに、数字の終わりを見たいとき、など
		- 次の文字が数字なら、読み続ける
		- 空白なら、読み飛ばし
		- 演算子なら、とりあえず一度戻してこれまでに読んだ数字列を変換
	- fgets()
		- 区切り文字を改行以外にすること、区切り文字自体もバッファに書くかどうか、など、オプションがある
		- そんなときは fgetc() によるループで代替も可能
		- バッファリングした上での話なので、大きな問題ではないが、fgets()に比べてfgetc()ループは呼び出し回数が増えるので、性能は劣るかもね
- アラインメントの注意事項：Intは4バイトごと。1バイトごと読むなんてことはしない。ふつうはコンパイラがいい感じにやる。しかし自前でメモリ管理したり、ネットワークプログラミングのバケットサイズなどの話になると、アラインメントを意識する必要がでるので要注意。
- バイナリデータ（e.g., 構造体）はfread
	- 読み取ったデータ個数が指定個 nr より小さければエラー
		- nr個よむ以前にEOFだったのか、他のエラーなのか、これは戻り値からはわからない
		- ferror(), feof()で判断する
- fgetc(), fgets() <-> fputc(), fputs()
- fwrite()：バイナリデータなど、行や文字単位で区切れない複雑な書き込み
- ファイルのシークは fseek()
	- 第3引数 WHENCE でoffsetの意味を指定
		- SEEK_END: 末尾からoffset分
		- SEEK_CUR: カレントからoffset分
		- SEEK_SET: ポジションがoffset
	- SEEK_SET を指定した場合と等価な fsetpos() もある
		- ストリームポジションの表現が long では不十分な場合
		- でもよほど全プラットフォームに対応したいのでなければ考慮しなくてもよい
- fseek(stream, 0, SEEK_SET) と等価な表現、rewind() もある
	- 戻り値がないので、errnoの値をチェック
	- errnoは #include<errno.h>
- lseek() とは異なり、fseek()は移動したポジションを返さない
	- ftell() を使うとlongを返して教えてくれる
	- 複雑なポジションには fgetpos() がある
- ユーザ空間のすべてのバッファをカーネルバッファに書き込む: fflush()
	- バッファリングなしで直接write()したのと同じ
	- カーネルバッファに書き込むだけなので、ディスク上に物理的に書き込まれることまでは保証しない
	- それをしたければ fsync()
	- fflush() -> fsync()
- fread()の戻り値はEOFとエラーを区別できなかった
	- ferror(), feof()：ストリームのエラー・EOF状態を返す（Bool)
	- clearerr() でその両方をクリアできる
- fileno() でストリームのファイルディスクリプタを得ることもできる
	- ただし標準I/Oライブラリとシステムコールの混在は避けるべき
- 標準I/Oライブラリができるバファfリングの種類
	- バッファリングなし
		- 直接カーネル空間へ書き込む
	- ラインバッファリング
		- 改行が書き込まれたらカーネル側に書き込む
	- ブロックバッファリング
		- ブロック単位でバッファリング（デフォルトはこれ、最適！）
		- stdioではフルバッファリングとも
	- setvbuf() で変更可能
		- バッファとして使うメモリも指定できる
		- 指定したのなら、『バッファが存在しない』とならないようにストリームがクローズされるまで確実にその領域を確保すること。returnするなら、明示的なストリームのクローズまたはbufのグローバル化が必要。
- stdio はスレッドセーフ
	- ライブラリ内部でストリームごとにロック、ロックカウント、オーナスレッドを対応付けている
	- e.g., fputs() * 3 呼んで3行書き込むとき、fputs()単体での競合はありえない
	- ただし、fputs()の間で他のスレッドが同じストリームに書き込むことは可能
	- それを避けるために、fputs() * 3全体に対してロックを掛けることもできる
		- flockfile(stream), funlockfile(stream)
		- すでにロックされている場合にロックしない、ftrylockfile() もある
- よりきめ細かいロックを実装してオーバヘッドを最小化するための、内部ロック未実装の読み書き関数 fgetc_unlocked(), fgets_unlocked() なども用意されている
- カーネルに対する read()によってカーネル空間からバッファへコピー、そしてアプリはfgets()などでバッファからデータを読み取り：これが二重コピーで気に食わないという説もある
	- ポインタ参照などに置き換えることで防ぐことも可能らしい
	- とはいえstdioは実用的には唯一のもの
- 最高の柔軟性はシステムコールの直接発行によってえられるけどね

### Chapter 4: 高度なファイルI/O

- **Linuxのより高度なI/Oシステムコール（4種類みる）**
- **1. scatter-gather I/O（前章のリニアI/Oとの対比でベクタI/Oとも）**
	- **複数のバッファを一度のシステムコールで1つのところにガッと書き込む/読み込む**
	- データがセグメントに分割されている場合でも、それらをまとめて直感的に処理できる
		- 愚直にバッファを結合/分割して読み書きを行う実装も可能だけど、手間がかかる
	- 複数のリニアI/Oを1つのベクタI/Oにまとめるので効率的
	- さらにベクタI/Oの内部的な最適化も手伝って、パフォーマンスUP
- **readv()**
	- **fdからバッファへcount個のセグメントを読む**
- **writev()**
	- **バッファからcount個のセグメントをfdへ書き込む**
- バッファ = count個のiovec構造体の配列によって指定
	- 普通のread(), write()と異なる点はここ
	- 各iovec構造体は独立したバッファ（セグメント）を表現
	- **複数のセグメントをまとめたもの ＝ ベクタ**
	- iov[0], iov[1], ..., iov[count-1] と順番に、対象セグメントの指定バイト数(iov_len)分のデータを読み書き
- 成功すればcount個のセグメントの iov_len の合計値を返す
	- 失敗したときの戻り値はread(), write()準拠
	- 合計値が上限を超える場合と、countが上限を超える場合はデータは処理されずにエラーを吐く
- ベクタ数(count値)に応じて、セグメント情報のメモリ割り当てを動的に行うか、静的に行うかを切り替える
	- セグメント数が少なければmallocのオーバヘッドを抑えて効率的に処理できる
- 例: writev()
	- 1行 = 1セグメント、iov_len = その行の文字数 
	- で、3行（セグメント）分をまとめて書き込む
- 例: readv()
	- 各行に対してセグメントを割り当て (foo, bar, baz; 文字数 iov_len は既知とする)
	- 3セグメント分をまとめて読み込む
	- foo分（＝1行分）の読み込み→bar分の読み込み→baz分の読み込み
- **writev(), readv()は複数のiovec構造体の情報に従ってシーケンシャルに読み書きをするだけなので、forで簡易的に実装できる**
	- が、実際はシステムコールレベルの話なのでこんな実装が存在するわけではない
	- write(), read()はベクタI/O readv(), writev() でセグメント数1の場合と等価
- **2. event poll (epoll)**
	- http://alpha.mixi.co.jp/entry/2007/10631/
		- **poll() では呼ばれるたびに監視下のディスクリプタセットをカーネルに渡して、状態が更新されて、帰ってきたのを1つ1つ調べて…とやっていた**: O(n)
			- ディスクリプタが何千、何万なら最悪
		- **epoll() は状態をカーネル内で監視**: O(1)
- **具体的には、epoll() は、poll()システムコールの仕事を3分割してfdの管理をいい感じにしたもの**
	1. epfd = **epoll_create**(size)
		- **epollコンテキストの作成**
		- fd数のヒントを渡す（あんまり気にしなくてい）
		- このepollコンテキストを表すfdを返す
	2. **epoll_ctl**(epfd, op, fd, epoll_event)
		- **epollコンテキスト epfd に fd を op する**
		- opの詳細は epoll_eventで設定
		- **op は　add, del, mod など**
		- epoll_event構造体の中で調べたいイベントの種類（例：エラー発生、読み取り可能になった）を設定したりする
	3. **epoll_wait**(epfd, epoll_event, maxevents, timeout)
		- 設定済fdについて、イベント発生を待つ
		- **発生したイベントはepoll_eventに入る = 1つ1つチェックしなくていい!** 
- epoll_ctlでを指定するとエッジトリガでfdを調べる（デフォはレベルトリガ）
 	- **レベルトリガ：イベントの「状態」を調べる**
		- e.g., 途中まで読んで、まだ読み取り可能なら即epoll_wait()抜ける
	- **エッジトリガ：イベントの「発生」を調べる**
		- e.g., まだ読み取り可能でも、**新しい書き込み（＝イベント発生）がない限りepoll_wait()を抜けない**
- **3. ファイルをメモリへマッピング**
	- **mmap**(addr, len, prot, flags, fd, offset) 
		- **ファイルデータ（バイト単位）をメモリアドレスと1対1対応にさせる**
		- メモリアクセス→ファイルへの直接アクセス
		- メモリ上のデータ変更 <-> ディスク上のファイル
		- prot でパーミッション設定, fd のオープン時のモードと一致させる
			- アーキテクチャによってフラグの種類が異なるので注意
			- 実行権限を与えていなくても、あるアーキテクチャでは読み込み権限さえ与えれば実行も可能にしてしまう
			- メモリ内に悪意のある機械語プログラムが送り込まれて実行される、バッファオーバーフロー攻撃につながることも
		- flagsでマッピングの詳細設定
		- マッピングした領域の先頭アドレスを返す
- **マッピングはページ単位**
	- アラインメントされてなければzero-padding
	- ページサイズは以下の方法で知れる
		- sysconf(\_SC\_PAGESIZE) 
		- getpagesize()
		- PAGE_SIZE: コンパイル時にページサイズをハードコードすることになるので良くない
	- まぁ実際は addr, offset は0にしちゃうので、ページサイズを厳密に考えるシチュエーションは稀だけど
- **munmap**(addr, len)
	- addr から　len バイト数分のページを削除
	- mmap()から帰ってきたaddrと、使ったlenをそのまま渡せばいい
- 例: 引数に渡してopenしたファイルをメモリに直割当（lenはfstat()から取る）→メモリから直読みしてprint→マッピングしたメモリ領域の削除
- **Pros**
	- read(), write() で発生した **ユーザ空間バッファとのコピー処理が無い**
	- **単なるメモリアクセスと変わらないので諸々のオーバヘッドがなくなる**
	- **データのプロセス間共有** が可能になる
	- **シーク＝単純なポインタ処理**; lseek()が不要に
- **Cons**
	- **zero-paddingによってメモリ上に無駄な空間が生まれる**
	- **フラグメンテーション** によって大きな領域の確保ができなくなる可能性
	- ユーザ側のコピー処理は無いけど、**カーネル側でメモリマップに関連する別のオーバヘッドがある。まぁ十分無視できるレベルだけど**
- **＝ファイルサイズが大きい/サイズがちょうどページサイズの整数倍のときがmmap()の良さが一番発揮されるとき**
- **mremap**()
	- マッピングしたメモリサイズを拡張、縮小する
	- malloc()で割り当てたサイズを変更するrealloc()の内部で使われたり。
- **mprotect**()
	- 指定した範囲のメモリページのパーミッション変更
- **msync**()
	- メモリマップしたファイルに対する変更をディスクに書き出す
	- **通常、munmap()されるまでカーネルが書き出すべきdirtyバッファとして認識してくれない**
	- flagsで同期処理を制御
		- 同期的にsyncする（＝完了までリターンしない）or非同期でsyncする
- **madvice**()
	- カーネルにマッピングしたメモリ領域をどう使用するかについてヒントを与える
	- **カーネルはこれを元に内部処理を最適化する、かもしれない**（実装依存；ファイルの先読み量の調整etc）
- **4. 通常のファイルI/Oでもヒントを与える**
	- posix_fadvice()
		- fdの[offset, offset+len)に対するアドバイス
		- madvice()とほぼ同じ
	- readahead()
		- posix_fadvice()とは違ってlinux固有
		- fdの指定範囲をページキャッシュに読み込んでおく
- **アドバイスは僅かな手間でI/Oがいい感じになる、高コスパ機能**
	- **動画ストリーミングならPOSIX_FADV_DONTNEEDを指定してキャッシュから消すようにしたり**
- **5. 2種類の同期/非同期**
- **イベントを待つか否か**
	- シンクロナス：少なくともカーネル内のバッファキャッシュへ書き込まれる、ユーザ空間のバッファへ読み取られるまでリターンしない（＝通常のR/W）
	- アシンクロナス：データがユーザ空間にとどまっていても、データが有効になる前でも、リターンする
		- 処理が単にキューに繋がっただけでリターンして、処理は後で行われる
		- 終了の通知が必要
- **どれほど厳密な意味で待つか（ディスクとの一致制）**
	- シンクロナイズドI/O：シンクロナスより厳密かつ確実。データをディスクに書き出すまで、同期が終わるまでリターンしない
	- ノンシンクロナイズド：カーネル内のバッファにコピーすればリターンする（ディスクとの同期までは保証しない）
- **Unix**
	- **書き込み：シンクロナス＆ノンシンクロナイズド**
		- **バッファキャッシュにあってデータが有効なことは保証するけど、ディスクとの一致までは保証しない**
	- **読み込み：シンクロナス＆シンクロナイズド**
		- **ベージキャッシュ内のデータは常にディスク上のデータと一致する（またはそれより新しい状態である）ことが保証**
- **非同期（アシンクロナス）I/O**
	- POSIXではglibcのaio_xxxというインタフェースで下位レベルの対応を実現
	- Linuxカーネルではio_submit()システムコールとaioカーネルスレッドを独自実装することで対応
		- io_submit() が aio_read(), aio_write(), aio_fsync() の役割を包括
- **非同期I/Oを必要とする場合は以下の2点**
	- **パフォーマンス的に、ブロックされずにI/Oを実行したい**（＝プロセスの非I/Oバウンド化）
	- **I/Oのキューイング、カーネルへの要求、完了通知を分離したい**
- **この2つを実現するスレッド実装の手引き：**
	- **すべてのI/Oを担当するワーカスレッド** をあらかじめ作成
	- **ワークキューの専用インタフェース** を作成
		- 渡されたI/O要求に一意に対応するI/Oディスクリプタを返す
		-	 ワーカスレッドはキューの先頭からI/O要求を取り出して、I/Oを発行して、完了を待つ
	- **I/Oが完了したら** 戻り値、errno、読み取ったデータなどを **結果キューにつなぐ**
	- **結果キューからI/O結果を取り出すインタフェース** を提供
		- ワークキューから返されたI/Oディスクリプタを元に結果を特定
- POSIXのaioではこんな実装を提供しているけど、スレッド管理のオーバヘッドが大きい

- **I/Oスケジューラ**
	- **ディスクI/Oは遅い！** 1シークにかかる時間は1プロセッササイクルの250万倍も遅い
	- **そこでOSカーネル上ではI/Oスケジューラを実装して、処理するI/O要求の順序および回数を管理することでシーク回数と移動量を最小化している**
- シリンダ(C)-ヘッダ(H)-セクタ(S) アドレッシング、**HDD（物理）**
	- プラッタ（CD的な）が積み重なってる
	- プラッタはトラックに分割され、トラックはセクタに分割される
	- シリンダが各プラッタ上のトラック（＝各プラッタで同じ位置にあるトラック群）を表し、ヘッダでプラッタを特定する
	- そしてセクタの値でトラック内のセクタを特定すれば、データ位置が特定
- **ディスクは <シリンダ, ヘッド, セクタ> の組み合わせをブロック番号（物理ブロック）にマッピングしてブロックからセクタを特定する**
	- **OSはブロック番号をHDDに渡せばよい**：論理ブロックアドレッシング
	- ソフトウェアの世界であるファイルシステムは論理ブロック（1または複数の物理ブロックに対応）を扱う
- **I/Oスケジューラの処理**
	- **マージ：隣接するI/O要求を組み合わせて1つのI/O要求に変換（要求回数の削減）**
	- **ソート：待機中のI/O要求をブロック番号の昇順に並び替える（ディスク移動量の削減；シークのオーバヘッド最小化）**
- 読み取りレイテンシ
	- 読み取り要求に対して最新データを返すために、キャッシュに存在しないデータに対する要求を行ったプロセスはディスク読み取り完了までブロックされる
- 読み取り要求はシリアライズされ、前の要求の完了に依存する
- **書き込み要求は非同期なのでディスクI/Oはその場では発生しない**
	- **アプリから見れば、ストリームに思考停止で流し込んでるだけ**
	- **一方カーネルとディスクが書き込みストリームにつきっきりになりかねず、読み取りに悪影響をおよぼすことも**
- **仮にスケジューラが”常に”ブロックをソートして処理していれば、遠いブロックがいつまでも読めず**、読み取りレイテンシ的にまずい
	- 初期のめちゃ単純な対策は **Linusエレベータ**
	- **一定時間以上残っているI/O要求はソートせずにキューへ追加**
- **Deadline I/O スケジューラ**
	- **エレベータをもう少しシステマティックに賢く実装**
	- **I/O要求キューに加えて、読み取りFIFOキューと書き込みFIFOキューを追加** して情報を記録・管理
	- 要求を発行順序でソート、制限時間を設定
	- **読み取りの方に短い持間を設定して、書き込みストリームにつきっきり状態を回避**
	- 制限時間がすぎてもキューの先頭要求が処理されなければ、スケジューラは処理を一時中断してFIFOキューの要求を処理する
	- スループット向上の為、同じFIFOキューにあるI/O要求もいくつか続けて処理
	- 結果として、どのI/O要求も「異常に長く時間がかかる」という事態は避けられる
- **Anticipatory I/Oスケジューラ**
	- **Deadline + 読み取りのディスパッチ要求があったときに少し待つ**
	- 今いる位置に近いところが次に要求されるだろうと“予測”して待つ
	- 大半の読み取り処理はディスク上で前後に依存関係をもつので、「予測して待ったことが無駄になる」という心配はない
- **CFQ (Complete Fair Queuing) I/O スケジューラ**
	- **バランス良い、おすすめ**
	- **プロセスごとに独自のキュー（タイムスライスつき）を用意して、各プロセスのキューをラウンドロビンで処理** していく
	- **キューの処理（タイムスライス消費or要求なしになるまで）→要求なしなら、次の要求を予測してそのキューで少し待つ→次のプロセスのキューへ**
	- **シンクロナイズドI/Oに高い優先度を割り当てることで、Writeにつきっきり問題を回避**
- **Noop I/O スケジューラ**
	- ソートは考えない、**マージだけする**
- **ディスクI/Oはシステムの中でも際立って遅い！ので、I/Oパフォーマンスを最大限に引き出していこう**
	- I/O処理のマージで処理数を最小化
	- I/Oのブロックサイズでのアラインメント
	- ユーザ空間バッファリング
	- ベクタI/O、位置指定I/O、非同期I/Oなど、高度なI/O処理で効率化
- カーネル側ではスケジューラでディスクシークを抑えている。アプリケーション我でできることは？
	- **I/O要求のマージ＆ソートをアプリケーションで独自にやることも可能**
		- **スケジューラがソートできる要求の数は限られているので、必ずしも連続した大量のI/Oすべてをキュー内で最適に処理できるわけではない**
		- **ならアプリ側でそこをきちんとやって渡してあげればよい**
	- アプリ側での要求ソートは **パス名、inode番号、物理ディスクブロック番号** を参照しながら行う
		- パス名
			- 大まかなソートとして有意義、実装しやすい
			- 同じディレクトリのファイルはディスク上でも隣接しやすい
			- ただしあくまで近似的なソートなので完璧ではないし、フラグメンテーションが進んでいればソートの効果は低くなる
		- inode番号
			- **一番多く利用されている**
			- inodeはすべてのファイルに対応してメタデータを格納していて、一意な番号をもつ
			- 一般に、物理ブロックで先にくるファイルはinode番号も若いので、これについてソートするのはパス名ソートより賢い
			- とはいえ、やっぱりフラグメンテーションでは精度が下がる
		- 物理ディスクブロック番号
			- ファイルシステム内の論理ブロック番号から物理ブロック番号を特定できる
			- stat()で使用している論理ブロック数入手→各論理ブロックごとにioctl()で対応する物理ブロック番号入手
			- 先頭の論理ブロックだけをキーにソートすることも可能
			- root権限が必須
			- 理想的なソートだけど、はじめに取り組む手法として最善とはいえない
			
### Chapter 7: ファイル、ディレクトリの管理

- すべてのファイルアクセスはinodeを介して行われる（inode番号 `ls -i` によって一意に識別）
	- パーミッション、アクセス時刻、オーナ、グループ、サイズetc、メタデータをいろいろ持ってる
- stat(path), fstat(fd), lstat(path)（シンボリックリンク自体；not リンク先の元ファイル） でファイルのメタデータが確認できる
	- stat構造体に入る
	- st_dev（ファイルが存在するデバイス）もとれる。「オープン済みファイルがネットワーク上でなく、物理デバイス上に存在するか（サンプルコード参照）」までわかる
- パーミッションの変更は chmod(path), fchmod(fd)
	- ファイルI/Oでファイルに与えたパーミッションと同じ感じに指定
	- ※パーミッション変更ができるプロセスであること
- オーナ変更：chown(path), lchown(path), fchown(fd)
	- chownはシンボリックリンク先の元ファイルのオーナを変更、lchownがシンボリックリンク自身のオーナを変更
	- ※グループを変更するときは、ファイルのグループが自身の所属するグループであること
	
- ファイルの拡張属性 (xattr) -- key-value pair
	- アプリからいろいろな用途で自由に作成、参照、設定、変更ができるメタデータたち
	- これをどこに、どうやって保存しているかはファイルシステム依存だけど（ext3ならinodeの空き領域）、
	- 実際にはカーネルがその差異をよしなに吸収してくれて、ファイルシステムに依存しない標準インタフェースを使用できる
- key:　`namespace.attribute` e.g., `user.mime_type`
	- 長さに上限はないけど、容量的な意味で限界はあるので注意
	- Linuxの拡張属性の名前空間は4種類で、それぞれ参照・変更が可能な範囲が異なる
		1. system: カーネル機能の実装に使用
		2. security: セキュリティモデルの実装に使用、
		3. trusted: ユーザ空間の情報を保存
		4. user: 一般プロセスが標準的に使用、パーミッションに対応したアクセス制御
- 可能な操作は4種類
	1. ファイル、キー => 値get
		- getxattr(path), lgetxattr(path), fgetxattr(fd)
	2. ファイル、キー、値 => 設定
		- setxattr(path) ... いつもどおりの規則 (l付き, f付き)
	3. ファイル => キー一覧get
		- listxattr(path) ...
	4. ファイル、キー => 削除
		- removexattr(path) ...
	- 名前空間 user の拡張属性はシンボリックリンクでは使用できないので l... を使うことはほとんどない
	
- ディレクトリ＝ファイル名-inode番号のリストを保持するもの
	- ファイル名：ディレクトリエントリ、
	- inode番号との対応：リンク
- as you know
	- ルートディレクトリ、サブディレクトリ
	- 絶対パス、相対パス
- 全プロセスは"カレントディレクトリ"を持っていて、親から受け継ぐ
	- i.e., プロセスのカレントワーキングディレクトリ
	- 相対パス解決の際の始点になったり
- getcwd()でとれます、Linux版ではNULL渡すと内部バッファからポインタが返ります。類似したやつもいくつかある、が使わない気がする
- 移動：chdir(path), fchdir(fd)
	- 実行中プロセスのwdに対してのみ有効なので、`cd` コマンドはシェルの内部コマンドとして実装されてシェル自身がchdir()を発行している
- getcwd() は`cd -`的な、あとで戻ってきたいシチュエーションで使える
	- open(current dir) ->  fchdir() で復帰、の方が良いパスをメモリ内に保持しなくていいので早い
- 作成：mkdir(path)
- 削除 rmdir(path)
	- -r オプションの再帰削除はパスを辿ってアプリ側で実装する必要あり
- ディレクトリのファイルリストを読む：opendir(path)
 	- ディレクトリストリーム \*DIR が返ってくる
	- dirfd(\*DIR) で対応するfdたちも得られる（POSIX非標準）
- ディレクトリストリームからの読み取り：readdir(\*DIR)
	- エントリをひとつずつ返す
- ストリーム閉じる：closedir()
- opendir -> readdird() ... search file -> closedir() のサンプル ***code***

- 同じinode（ファイル）を2つの名前（パス）から参照するのはOK
	- ハードリンク
	- ＝ディレクトリエントリの追加
	- link(oldpath, newpath)
	- どちらが「元」で、どちらが「主」かの区別はない
- シンボリックリンク
	- 単にエントリを追加するのではなく、専用ファイルに他のファイルのパス名を格納する間接的な？リンク
	- symlink(oldpath, newpath)
- unlink() リンクの削除、つまり実質的にファイルの削除処理を行うシステムコール
	- Cには remove() 関数があるよ

- ファイルコピー　`cp`　＝　ファイルの内容を新規パスへ複写
	- 専用のシステムコールもライブラリも、Unixにはない
	1. open src
	2. open dst
	4. read src to memory
	5. write memory to dst
	6. close dst
	7. close src
- ファイル移動　`mv`　＝　ディレクトリエントリのファイル名の変更
	- システムコールは rename(oldpath, newpath)
	
- デバイスノード
	- アプリがデバドラへアクセスするためのスペシャルファイル
	- デバイスノードに対する read() write() ... はデバドラに渡る
	- メジャー番号、マイナー番号をカーネルにロードされたデバドラにマッピング
- 特殊なデバイスノード
	- nullデバイス /dev/null
		- 書き込みはカーネルが全破壊、読み取ると常にEOF
	- zeroデバイス /dev/zero
		- 書き込みはカーネルが全破壊、読み取りは永遠にNULL
	- fullデバイス /dev/full
		- 読み取りは永遠にNULL、書き込みは常時エラー
	- 悪い状態のテストで使える
- 乱数生成デバイス /dev/random, /dev/urandom
	- ノイズ収集→ハッシュ→ **エントロピープール** に蓄える
	- /dev/random への読み取りはプールの値を返す。これが乱数
	- エントロピープールの見積もりによって攻撃が可能になりかねないが、実例ナシ。カーネル側でもプールの状況に応じてブロックするなど対策してる
	- /dev/urandom はもうすこしガバガバ。でも実用上乱数が必要なシナリオはそれほどしっかりしてなくていいので、常用するにはこっちが多い。
	- 不用意に /dev/random を使うとめっちゃブロックされる可能性も
	
- ioctl(fd, request) で帯域外通信
	- openしたCDROMデバイスにEJECTコマンドを発行、とか ***code***
	
- ファイルイベント（移動、読み取り、書き込み、削除イベント）監視 inotify 
	- 定期的なディレクトリの再読み取りは変更検知には使えない（再読み取りタイミングと削除・変更が競合する可能性）
	- inotify なら、そういったイベントをカーネルがアプリに通知してくれる
	- 初期化 inotify_init() => ウォッチ inotify_add_watch()
	- watchディスクリプタ (wd) は監視したいイベントを表現したり
	- inotify_event構造体でイベントを表現 ***code***
	- 移動のイベントは FROM, TO の2つにわかれる。これを対応付けるのはcookieで、cookie値の同じイベントを一緒に
	- inotify_rm_watch(fd, wd) でウォッチ削除
	- イベントのキューサイズも取れる
	- close(fd) でインスタンスも関連ウォッチも削除される

### Chapter 9: シグナル

- シグナル：非同期イベントを処理するためのソフトウェア割り込みの一種（Ctrl+Cから、IPCでのプロセス間の送受信まで）
- シグナルのライフサイクル
	1. 生成
	2. 保留（カーネルが配送可能になるまで）
	3. 処理（カーネルによって）
		- 処理内容は３種類
		- 1. 無視
			- さすがにどうやってもプロセスを殺せない、はこまるのでSIGKILLとSIGSTOPは無視できない
		- 2. 捕捉＆処理
			- カーネルが現在の処理を中断→登録された関数へジャンプして実行→帰ってくる
		- 3. デフォルト動作
			- シグナル依存
- シグナル名は ***SIG...*** で、その実態はある整数値（セッション端末切断時のSIGHUP=1から始まって、31くらいまでで、<signal.h>にある）
	- 0はnullシグナル
- シグナルの詳細いろいろ（長い）
	- SIGCHLD: プロセスの終了を親に伝える
		- wait() はこのシグナルを捕捉して処理する
	- SIGHUP: セッション切断；Apacheに送信するとデーモンがhttpd.confを再読込してくれる
	- SIGINT: Ctrl-C
	- SIGKILL: 無条件かつ確実にプロセスを殺す手段；捕捉や無視はできない
	- SIGSEGV: セグメンテーション違反（メモリへの不正なアクセス）で送信される
- `signal(signo, handler)` シグナル捕捉時の動作をあるハンドラ関数に設定する
	- ハンドラ関数は戻り値voidで、引数は `signo` 1つのみ
	- 「デフォルト動作」「無視する」用のハンドラは予め定義されている
- `pause()` 任意のシグナルを待つシステムコール
	- デバッグ、デモ用途
	- 無限ループ内で呼び出して設定したハンドラの挙動をテストしたり
	- ***code*** シグナルの現在の動作を確認した上で `signal()` で設定
- 通常親で設定したハンドラは子ではすべてデフォルトに戻るが、アドレス空間を親子で共有する `fork()` の場合は受け継いでくれる
	- このあたりはシェルがバックグラウンドプロセスを起動したときとかに考える話
- シグナル番号をシグナル名の文字列に変換する方法もあるよ
- シグナルの送信
	- `kill(pid, signo)` シグナルsignoをプロセスpidに送信
		- pid=0: 自分と同じグループの全プロセスに送信
		- pid=-1: 自分とinitを除く、送信可能な全プロセスに送信
		- pid<-1: プロセスグループ "-pid" の全プロセスに送信
		- rootのように特別にCAP_KILLケーパビリティを持たない限り、ユーザは自分のプロセスへしかシグナルを送信できない
		- nullシグナルは権限チェック用のdry-run的に使える
	- 自分自身にシグナル送信 `raise(signo)`
	- あるプロセスグループの全プロセスに送信 `killpg(pgrp, signo)`
- 『シグナル発生時にプログラムがなにを実行していたか』はわからないので、どのタイミングで呼ばれても困らないハンドラ実装が重要（e.g., グローバル変数にさわらない）
- ハンドラが使える関数はリエントラント（自身からor同じプロセス内の別スレッドから並列に実行可能；シグナルセーフ）でなければならない
- シグナルセット：ブロックしたシグナル群や保留したシグナル群など、複数のシグナルの集合体
	- セット単位でなにか操作することもある
	- 初期化
		- `sigemptyset()` 空にする
		- `sigfillset()` 全シグナルをセット
	- 追加addset, 削除delset, 確認ismember
- どうしてもシグナルに割り込んでほしくない部分があったり、ハンドラとプログラム本体でのデータ共有が必要なときもある。そんなクリティカルセクションを保護するために、シグナルをブロックすることができる
	- ブロックしたシグナル群＝シグナルマスク
		- `sigprocmask()` でシグナルセットに対して設定できる 
	- カーネルがブロックされているシグナルを発生した場合、プロセスへは送信されない：保留状態
		- ブロックが解除されると送信する
		- `sigpending(set)` で確認できる
	- `sigsuspend(set)` で指定したシグナルを待てるので、これでクリティカルセクション実行後に、実行中に発生したシグナルを受信する
		- 全体のブロックを解除せずともシグナル単位で事後受信できる？
- `signal()` は単純だったけど、 `sigaction()` でより高度なシグナルの設定ができる
	- ハンドラ、ハンドラ実行中のシグナルブロック、シグナル発生時のプロセス状態などを `sigaction` 構造体で一挙に設定できる
	- いろいろフラグによって設定できる項目がある
		- SIGINFOフラグをつけると、シグナル動作が従来のハンドラ関数よりも複雑な関数になる
			- この関数はsiginfo_t構造体を引数にとる
			- signoだけじゃない、いろいろな情報を渡せる
				- si_code (signal code) を渡すと、シグナル発生の理由をハンドラに伝えられる
				- si_value では自由な追加データをハンドラに渡せる->IPCへ
					- `sigqueue()` でsignal valueを含んだシグナルを発生できる
					- signal value は整数とvoidポインタの共用体
- シグナルは原始的なIPC方法だけど、重要（現にこれまでの章でも何回も参照された）
- リエントラントで安全な、正しいハンドラを書くのは難しい 
- `signal()`, `kill()` -> `sigaction()`, `sigqueue()` にするとSIGINFOの恩恵をうけてパワフルになるのになぁ