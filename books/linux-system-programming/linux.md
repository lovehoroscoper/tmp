### Chapter 3: I/Oのバッファリング

- すべてのディスクI/Oはブロックにもとづいて処理されるので、ブロックサイズでアラインメントされたI/Oのほうがパフォーマンス的に有利
- サイズの小さなI/Oを多数発行する必要のあるI/O→ユーザバッファリングI/O
	- カーネル側での遅延書き込み、先読みによる内部バッファリングと同様に、パフォーマンス向上を狙ったもの
- ブロックサイズ単位のコピーのほうが、たとえシステムコールの回数が増えたとしても高速になる
	- ブロックサイズ＝カーネルとハードウェアのやり取りの単位そのものだから、余計な処理を発生させなくて済むため
	- アラインメントの範囲内でできるだけシステムコールの回数を減らすためには、大きめのブロックサイズ整数倍を使用する
- ただし、アプリケーション自体の処理単位がブロックサイズの整数倍、なんてことはまぁ無い話（1行とか、せいぜいそんなレベル）
	- というわけで、データは一度プロセス空間のバッファに蓄えられる
	- バッファサイズに達したところで、一度に書き出し
	- 読み込みも、バッファサイズ分いっきに読んだ上で、アプリには磯の一部を渡す
	- ブロックサイズ整数倍のバッファサイズを設定して読み書きを行ってあげればいい
- そんなユーザ空間のバッファリングを提供するものがStandard I/O
	- CはI/Oを処理する機能を言語自体には本来包括していない。ユーザによって開発されたI/Oの機能セットがstdio
	- 1. StandardIOを使うか、
	- 2. 自作のユーザ空間バッファリングを使うか、
	- 3. そもそもユーザ空間ではバッファリングしないシステムコールを使用するか、
	- これはアプリケーションの要求と動作を鑑みて開発者が判断すべき
- ファイルポインタをファイルディスクリプタに対応付けて、ユーザ側はファイルポインタを使用
	- オープンしたファイル：ストリーム（入力ストリーム＆出力ストリーム）
		- stream = fopen
- open()済ファイルディスクリプタのストリームへの変換: stream = fdopen(fd, "r")
	- streamはfdと対応づいている（参照している）だけなので、streamを閉じればfdも閉じる
- fclose(stream), floseall() // 標準入・出・エラーも閉じちゃう
- fgetc()
- ungetc(): 次の文字の先読み、POSIXでは確実に戻せるのは1文字のみ、Linuxはいくらでも戻せて、戻した順番の逆順で次は読まれる
	- つまり、一度読んだ文字を「読まなかったことにする」
	- 式をパースするときに、数字の終わりを見たいとき、など
		- 次の文字が数字なら、読み続ける
		- 空白なら、読み飛ばし
		- 演算子なら、とりあえず一度戻してこれまでに読んだ数字列を変換
	- fgets()
		- 区切り文字を改行以外にすること、区切り文字自体もバッファに書くかどうか、など、オプションがある
		- そんなときは fgetc() によるループで代替も可能
		- バッファリングした上での話なので、大きな問題ではないが、fgets()に比べてfgetc()ループは呼び出し回数が増えるので、性能は劣るかもね
- アラインメントの注意事項：Intは4バイトごと。1バイトごと読むなんてことはしない。ふつうはコンパイラがいい感じにやる。しかし自前でメモリ管理したり、ネットワークプログラミングのバケットサイズなどの話になると、アラインメントを意識する必要がでるので要注意。
- バイナリデータ（e.g., 構造体）はfread
	- 読み取ったデータ個数が指定個 nr より小さければエラー
		- nr個よむ以前にEOFだったのか、他のエラーなのか、これは戻り値からはわからない
		- ferror(), feof()で判断する
- fgetc(), fgets() <-> fputc(), fputs()
- fwrite()：バイナリデータなど、行や文字単位で区切れない複雑な書き込み
- ファイルのシークは fseek()
	- 第3引数 WHENCE でoffsetの意味を指定
		- SEEK_END: 末尾からoffset分
		- SEEK_CUR: カレントからoffset分
		- SEEK_SET: ポジションがoffset
	- SEEK_SET を指定した場合と等価な fsetpos() もある
		- ストリームポジションの表現が long では不十分な場合
		- でもよほど全プラットフォームに対応したいのでなければ考慮しなくてもよい
- fseek(stream, 0, SEEK_SET) と等価な表現、rewind() もある
	- 戻り値がないので、errnoの値をチェック
	- errnoは #include<errno.h>
- lseek() とは異なり、fseek()は移動したポジションを返さない
	- ftell() を使うとlongを返して教えてくれる
	- 複雑なポジションには fgetpos() がある
- ユーザ空間のすべてのバッファをカーネルバッファに書き込む: fflush()
	- バッファリングなしで直接write()したのと同じ
	- カーネルバッファに書き込むだけなので、ディスク上に物理的に書き込まれることまでは保証しない
	- それをしたければ fsync()
	- fflush() -> fsync()
- fread()の戻り値はEOFとエラーを区別できなかった
	- ferror(), feof()：ストリームのエラー・EOF状態を返す（Bool)
	- clearerr() でその両方をクリアできる
- fileno() でストリームのファイルディスクリプタを得ることもできる
	- ただし標準I/Oライブラリとシステムコールの混在は避けるべき
- 標準I/Oライブラリができるバファfリングの種類
	- バッファリングなし
		- 直接カーネル空間へ書き込む
	- ラインバッファリング
		- 改行が書き込まれたらカーネル側に書き込む
	- ブロックバッファリング
		- ブロック単位でバッファリング（デフォルトはこれ、最適！）
		- stdioではフルバッファリングとも
	- setvbuf() で変更可能
		- バッファとして使うメモリも指定できる
		- 指定したのなら、『バッファが存在しない』とならないようにストリームがクローズされるまで確実にその領域を確保すること。returnするなら、明示的なストリームのクローズまたはbufのグローバル化が必要。
- stdio はスレッドセーフ
	- ライブラリ内部でストリームごとにロック、ロックカウント、オーナスレッドを対応付けている
	- e.g., fputs() * 3 呼んで3行書き込むとき、fputs()単体での競合はありえない
	- ただし、fputs()の間で他のスレッドが同じストリームに書き込むことは可能
	- それを避けるために、fputs() * 3全体に対してロックを掛けることもできる
		- flockfile(stream), funlockfile(stream)
		- すでにロックされている場合にロックしない、ftrylockfile() もある
- よりきめ細かいロックを実装してオーバヘッドを最小化するための、内部ロック未実装の読み書き関数 fgetc_unlocked(), fgets_unlocked() なども用意されている
- カーネルに対する read()によってカーネル空間からバッファへコピー、そしてアプリはfgets()などでバッファからデータを読み取り：これが二重コピーで気に食わないという説もある
	- ポインタ参照などに置き換えることで防ぐことも可能らしい
	- とはいえstdioは実用的には唯一のもの
- 最高の柔軟性はシステムコールの直接発行によってえられるけどね