### Chapter 3: I/Oのバッファリング

- すべてのディスクI/Oはブロックにもとづいて処理されるので、ブロックサイズでアラインメントされたI/Oのほうがパフォーマンス的に有利
- サイズの小さなI/Oを多数発行する必要のあるI/O→ユーザバッファリングI/O
	- カーネル側での遅延書き込み、先読みによる内部バッファリングと同様に、パフォーマンス向上を狙ったもの
- ブロックサイズ単位のコピーのほうが、たとえシステムコールの回数が増えたとしても高速になる
	- ブロックサイズ＝カーネルとハードウェアのやり取りの単位そのものだから、余計な処理を発生させなくて済むため
	- アラインメントの範囲内でできるだけシステムコールの回数を減らすためには、大きめのブロックサイズ整数倍を使用する
- ただし、アプリケーション自体の処理単位がブロックサイズの整数倍、なんてことはまぁ無い話（1行とか、せいぜいそんなレベル）
	- というわけで、データは一度プロセス空間のバッファに蓄えられる
	- バッファサイズに達したところで、一度に書き出し
	- 読み込みも、バッファサイズ分いっきに読んだ上で、アプリには磯の一部を渡す
	- ブロックサイズ整数倍のバッファサイズを設定して読み書きを行ってあげればいい
- そんなユーザ空間のバッファリングを提供するものがStandard I/O
	- CはI/Oを処理する機能を言語自体には本来包括していない。ユーザによって開発されたI/Oの機能セットがstdio
	- 1. StandardIOを使うか、
	- 2. 自作のユーザ空間バッファリングを使うか、
	- 3. そもそもユーザ空間ではバッファリングしないシステムコールを使用するか、
	- これはアプリケーションの要求と動作を鑑みて開発者が判断すべき
- ファイルポインタをファイルディスクリプタに対応付けて、ユーザ側はファイルポインタを使用
	- オープンしたファイル：ストリーム（入力ストリーム＆出力ストリーム）
		- stream = fopen
- open()済ファイルディスクリプタのストリームへの変換: stream = fdopen(fd, "r")
	- streamはfdと対応づいている（参照している）だけなので、streamを閉じればfdも閉じる
- fclose(stream), floseall() // 標準入・出・エラーも閉じちゃう
- fgetc()
- ungetc(): 次の文字の先読み、POSIXでは確実に戻せるのは1文字のみ、Linuxはいくらでも戻せて、戻した順番の逆順で次は読まれる
	- つまり、一度読んだ文字を「読まなかったことにする」
	- 式をパースするときに、数字の終わりを見たいとき、など
		- 次の文字が数字なら、読み続ける
		- 空白なら、読み飛ばし
		- 演算子なら、とりあえず一度戻してこれまでに読んだ数字列を変換
	- fgets()
		- 区切り文字を改行以外にすること、区切り文字自体もバッファに書くかどうか、など、オプションがある
		- そんなときは fgetc() によるループで代替も可能
		- バッファリングした上での話なので、大きな問題ではないが、fgets()に比べてfgetc()ループは呼び出し回数が増えるので、性能は劣るかもね
- アラインメントの注意事項：Intは4バイトごと。1バイトごと読むなんてことはしない。ふつうはコンパイラがいい感じにやる。しかし自前でメモリ管理したり、ネットワークプログラミングのバケットサイズなどの話になると、アラインメントを意識する必要がでるので要注意。
- バイナリデータ（e.g., 構造体）はfread
	- 読み取ったデータ個数が指定個 nr より小さければエラー
		- nr個よむ以前にEOFだったのか、他のエラーなのか、これは戻り値からはわからない
		- ferror(), feof()で判断する
- fgetc(), fgets() <-> fputc(), fputs()
- fwrite()：バイナリデータなど、行や文字単位で区切れない複雑な書き込み
- ファイルのシークは fseek()
	- 第3引数 WHENCE でoffsetの意味を指定
		- SEEK_END: 末尾からoffset分
		- SEEK_CUR: カレントからoffset分
		- SEEK_SET: ポジションがoffset
	- SEEK_SET を指定した場合と等価な fsetpos() もある
		- ストリームポジションの表現が long では不十分な場合
		- でもよほど全プラットフォームに対応したいのでなければ考慮しなくてもよい
- fseek(stream, 0, SEEK_SET) と等価な表現、rewind() もある
	- 戻り値がないので、errnoの値をチェック
	- errnoは #include<errno.h>
- lseek() とは異なり、fseek()は移動したポジションを返さない
	- ftell() を使うとlongを返して教えてくれる
	- 複雑なポジションには fgetpos() がある
- ユーザ空間のすべてのバッファをカーネルバッファに書き込む: fflush()
	- バッファリングなしで直接write()したのと同じ
	- カーネルバッファに書き込むだけなので、ディスク上に物理的に書き込まれることまでは保証しない
	- それをしたければ fsync()
	- fflush() -> fsync()
- fread()の戻り値はEOFとエラーを区別できなかった
	- ferror(), feof()：ストリームのエラー・EOF状態を返す（Bool)
	- clearerr() でその両方をクリアできる
- fileno() でストリームのファイルディスクリプタを得ることもできる
	- ただし標準I/Oライブラリとシステムコールの混在は避けるべき
- 標準I/Oライブラリができるバファfリングの種類
	- バッファリングなし
		- 直接カーネル空間へ書き込む
	- ラインバッファリング
		- 改行が書き込まれたらカーネル側に書き込む
	- ブロックバッファリング
		- ブロック単位でバッファリング（デフォルトはこれ、最適！）
		- stdioではフルバッファリングとも
	- setvbuf() で変更可能
		- バッファとして使うメモリも指定できる
		- 指定したのなら、『バッファが存在しない』とならないようにストリームがクローズされるまで確実にその領域を確保すること。returnするなら、明示的なストリームのクローズまたはbufのグローバル化が必要。
- stdio はスレッドセーフ
	- ライブラリ内部でストリームごとにロック、ロックカウント、オーナスレッドを対応付けている
	- e.g., fputs() * 3 呼んで3行書き込むとき、fputs()単体での競合はありえない
	- ただし、fputs()の間で他のスレッドが同じストリームに書き込むことは可能
	- それを避けるために、fputs() * 3全体に対してロックを掛けることもできる
		- flockfile(stream), funlockfile(stream)
		- すでにロックされている場合にロックしない、ftrylockfile() もある
- よりきめ細かいロックを実装してオーバヘッドを最小化するための、内部ロック未実装の読み書き関数 fgetc_unlocked(), fgets_unlocked() なども用意されている
- カーネルに対する read()によってカーネル空間からバッファへコピー、そしてアプリはfgets()などでバッファからデータを読み取り：これが二重コピーで気に食わないという説もある
	- ポインタ参照などに置き換えることで防ぐことも可能らしい
	- とはいえstdioは実用的には唯一のもの
- 最高の柔軟性はシステムコールの直接発行によってえられるけどね

### Chapter 4: 高度なファイルI/O

- **Linuxのより高度なI/Oシステムコール（4種類みる）**
- **1. scatter-gather I/O（前章のリニアI/Oとの対比でベクタI/Oとも）**
	- **複数のバッファを一度のシステムコールで1つのところにガッと書き込む/読み込む**
	- データがセグメントに分割されている場合でも、それらをまとめて直感的に処理できる
		- 愚直にバッファを結合/分割して読み書きを行う実装も可能だけど、手間がかかる
	- 複数のリニアI/Oを1つのベクタI/Oにまとめるので効率的
	- さらにベクタI/Oの内部的な最適化も手伝って、パフォーマンスUP
- **readv()**
	- **fdからバッファへcount個のセグメントを読む**
- **writev()**
	- **バッファからcount個のセグメントをfdへ書き込む**
- バッファ = count個のiovec構造体の配列によって指定
	- 普通のread(), write()と異なる点はここ
	- 各iovec構造体は独立したバッファ（セグメント）を表現
	- **複数のセグメントをまとめたもの ＝ ベクタ**
	- iov[0], iov[1], ..., iov[count-1] と順番に、対象セグメントの指定バイト数(iov_len)分のデータを読み書き
- 成功すればcount個のセグメントの iov_len の合計値を返す
	- 失敗したときの戻り値はread(), write()準拠
	- 合計値が上限を超える場合と、countが上限を超える場合はデータは処理されずにエラーを吐く
- ベクタ数(count値)に応じて、セグメント情報のメモリ割り当てを動的に行うか、静的に行うかを切り替える
	- セグメント数が少なければmallocのオーバヘッドを抑えて効率的に処理できる
- 例: writev()
	- 1行 = 1セグメント、iov_len = その行の文字数 
	- で、3行（セグメント）分をまとめて書き込む
- 例: readv()
	- 各行に対してセグメントを割り当て (foo, bar, baz; 文字数 iov_len は既知とする)
	- 3セグメント分をまとめて読み込む
	- foo分（＝1行分）の読み込み→bar分の読み込み→baz分の読み込み
- **writev(), readv()は複数のiovec構造体の情報に従ってシーケンシャルに読み書きをするだけなので、forで簡易的に実装できる**
	- が、実際はシステムコールレベルの話なのでこんな実装が存在するわけではない
	- write(), read()はベクタI/O readv(), writev() でセグメント数1の場合と等価
- **2. event poll (epoll)**
	- http://alpha.mixi.co.jp/entry/2007/10631/
		- **poll() では呼ばれるたびに監視下のディスクリプタセットをカーネルに渡して、状態が更新されて、帰ってきたのを1つ1つ調べて…とやっていた**: O(n)
			- ディスクリプタが何千、何万なら最悪
		- **epoll() は状態をカーネル内で監視**: O(1)
- **具体的には、epoll() は、poll()システムコールの仕事を3分割してfdの管理をいい感じにしたもの**
	1. epfd = **epoll_create**(size)
		- **epollコンテキストの作成**
		- fd数のヒントを渡す（あんまり気にしなくてい）
		- このepollコンテキストを表すfdを返す
	2. **epoll_ctl**(epfd, op, fd, epoll_event)
		- **epollコンテキスト epfd に fd を op する**
		- opの詳細は epoll_eventで設定
		- **op は　add, del, mod など**
		- epoll_event構造体の中で調べたいイベントの種類（例：エラー発生、読み取り可能になった）を設定したりする
	3. **epoll_wait**(epfd, epoll_event, maxevents, timeout)
		- 設定済fdについて、イベント発生を待つ
		- **発生したイベントはepoll_eventに入る = 1つ1つチェックしなくていい!** 
- epoll_ctlでを指定するとエッジトリガでfdを調べる（デフォはレベルトリガ）
 	- **レベルトリガ：イベントの「状態」を調べる**
		- e.g., 途中まで読んで、まだ読み取り可能なら即epoll_wait()抜ける
	- **エッジトリガ：イベントの「発生」を調べる**
		- e.g., まだ読み取り可能でも、**新しい書き込み（＝イベント発生）がない限りepoll_wait()を抜けない**
- **3. ファイルをメモリへマッピング**
	- **mmap**(addr, len, prot, flags, fd, offset) 
		- **ファイルデータ（バイト単位）をメモリアドレスと1対1対応にさせる**
		- メモリアクセス→ファイルへの直接アクセス
		- メモリ上のデータ変更 <-> ディスク上のファイル
		- prot でパーミッション設定, fd のオープン時のモードと一致させる
			- アーキテクチャによってフラグの種類が異なるので注意
			- 実行権限を与えていなくても、あるアーキテクチャでは読み込み権限さえ与えれば実行も可能にしてしまう
			- メモリ内に悪意のある機械語プログラムが送り込まれて実行される、バッファオーバーフロー攻撃につながることも
		- flagsでマッピングの詳細設定
		- マッピングした領域の先頭アドレスを返す
- **マッピングはページ単位**
	- アラインメントされてなければzero-padding
	- ページサイズは以下の方法で知れる
		- sysconf(\_SC\_PAGESIZE) 
		- getpagesize()
		- PAGE_SIZE: コンパイル時にページサイズをハードコードすることになるので良くない
	- まぁ実際は addr, offset は0にしちゃうので、ページサイズを厳密に考えるシチュエーションは稀だけど
- **munmap**(addr, len)
	- addr から　len バイト数分のページを削除
	- mmap()から帰ってきたaddrと、使ったlenをそのまま渡せばいい
- 例: 引数に渡してopenしたファイルをメモリに直割当（lenはfstat()から取る）→メモリから直読みしてprint→マッピングしたメモリ領域の削除
- **Pros**
	- read(), write() で発生した **ユーザ空間バッファとのコピー処理が無い**
	- **単なるメモリアクセスと変わらないので諸々のオーバヘッドがなくなる**
	- **データのプロセス間共有** が可能になる
	- **シーク＝単純なポインタ処理**; lseek()が不要に
- **Cons**
	- **zero-paddingによってメモリ上に無駄な空間が生まれる**
	- **フラグメンテーション** によって大きな領域の確保ができなくなる可能性
	- ユーザ側のコピー処理は無いけど、**カーネル側でメモリマップに関連する別のオーバヘッドがある。まぁ十分無視できるレベルだけど**
- **＝ファイルサイズが大きい/サイズがちょうどページサイズの整数倍のときがmmap()の良さが一番発揮されるとき**
- **mremap**()
	- マッピングしたメモリサイズを拡張、縮小する
	- malloc()で割り当てたサイズを変更するrealloc()の内部で使われたり。
- **mprotect**()
	- 指定した範囲のメモリページのパーミッション変更
- **msync**()
	- メモリマップしたファイルに対する変更をディスクに書き出す
	- **通常、munmap()されるまでカーネルが書き出すべきdirtyバッファとして認識してくれない**
	- flagsで同期処理を制御
		- 同期的にsyncする（＝完了までリターンしない）or非同期でsyncする
- **madvice**()
	- カーネルにマッピングしたメモリ領域をどう使用するかについてヒントを与える
	- **カーネルはこれを元に内部処理を最適化する、かもしれない**（実装依存；ファイルの先読み量の調整etc）
- **4. 通常のファイルI/Oでもヒントを与える**
	- posix_fadvice()
		- fdの[offset, offset+len)に対するアドバイス
		- madvice()とほぼ同じ
	- readahead()
		- posix_fadvice()とは違ってlinux固有
		- fdの指定範囲をページキャッシュに読み込んでおく
- **アドバイスは僅かな手間でI/Oがいい感じになる、高コスパ機能**
	- **動画ストリーミングならPOSIX_FADV_DONTNEEDを指定してキャッシュから消すようにしたり**
- **5. 2種類の同期/非同期**
- **イベントを待つか否か**
	- シンクロナス：少なくともカーネル内のバッファキャッシュへ書き込まれる、ユーザ空間のバッファへ読み取られるまでリターンしない（＝通常のR/W）
	- アシンクロナス：データがユーザ空間にとどまっていても、データが有効になる前でも、リターンする
		- 処理が単にキューに繋がっただけでリターンして、処理は後で行われる
		- 終了の通知が必要
- **どれほど厳密な意味で待つか（ディスクとの一致制）**
	- シンクロナイズドI/O：シンクロナスより厳密かつ確実。データをディスクに書き出すまで、同期が終わるまでリターンしない
	- ノンシンクロナイズド：カーネル内のバッファにコピーすればリターンする（ディスクとの同期までは保証しない）
- **Unix**
	- **書き込み：シンクロナス＆ノンシンクロナイズド**
		- **バッファキャッシュにあってデータが有効なことは保証するけど、ディスクとの一致までは保証しない**
	- **読み込み：シンクロナス＆シンクロナイズド**
		- **ベージキャッシュ内のデータは常にディスク上のデータと一致する（またはそれより新しい状態である）ことが保証**
- **非同期（アシンクロナス）I/O**
	- POSIXではglibcのaio_xxxというインタフェースで下位レベルの対応を実現
	- Linuxカーネルではio_submit()システムコールとaioカーネルスレッドを独自実装することで対応
		- io_submit() が aio_read(), aio_write(), aio_fsync() の役割を包括
- **非同期I/Oを必要とする場合は以下の2点**
	- **パフォーマンス的に、ブロックされずにI/Oを実行したい**（＝プロセスの非I/Oバウンド化）
	- **I/Oのキューイング、カーネルへの要求、完了通知を分離したい**
- **この2つを実現するスレッド実装の手引き：**
	- **すべてのI/Oを担当するワーカスレッド** をあらかじめ作成
	- **ワークキューの専用インタフェース** を作成
		- 渡されたI/O要求に一意に対応するI/Oディスクリプタを返す
		-	 ワーカスレッドはキューの先頭からI/O要求を取り出して、I/Oを発行して、完了を待つ
	- **I/Oが完了したら** 戻り値、errno、読み取ったデータなどを **結果キューにつなぐ**
	- **結果キューからI/O結果を取り出すインタフェース** を提供
		- ワークキューから返されたI/Oディスクリプタを元に結果を特定
- POSIXのaioではこんな実装を提供しているけど、スレッド管理のオーバヘッドが大きい

- **I/Oスケジューラ**
	- **ディスクI/Oは遅い！** 1シークにかかる時間は1プロセッササイクルの250万倍も遅い
	- **そこでOSカーネル上ではI/Oスケジューラを実装して、処理するI/O要求の順序および回数を管理することでシーク回数と移動量を最小化している**
- シリンダ(C)-ヘッダ(H)-セクタ(S) アドレッシング、**HDD（物理）**
	- プラッタ（CD的な）が積み重なってる
	- プラッタはトラックに分割され、トラックはセクタに分割される
	- シリンダが各プラッタ上のトラック（＝各プラッタで同じ位置にあるトラック群）を表し、ヘッダでプラッタを特定する
	- そしてセクタの値でトラック内のセクタを特定すれば、データ位置が特定
- **ディスクは <シリンダ, ヘッド, セクタ> の組み合わせをブロック番号（物理ブロック）にマッピングしてブロックからセクタを特定する**
	- **OSはブロック番号をHDDに渡せばよい**：論理ブロックアドレッシング
	- ソフトウェアの世界であるファイルシステムは論理ブロック（1または複数の物理ブロックに対応）を扱う
- **I/Oスケジューラの処理**
	- **マージ：隣接するI/O要求を組み合わせて1つのI/O要求に変換（要求回数の削減）**
	- **ソート：待機中のI/O要求をブロック番号の昇順に並び替える（ディスク移動量の削減；シークのオーバヘッド最小化）**
- 読み取りレイテンシ
	- 読み取り要求に対して最新データを返すために、キャッシュに存在しないデータに対する要求を行ったプロセスはディスク読み取り完了までブロックされる
- 読み取り要求はシリアライズされ、前の要求の完了に依存する
- **書き込み要求は非同期なのでディスクI/Oはその場では発生しない**
	- **アプリから見れば、ストリームに思考停止で流し込んでるだけ**
	- **一方カーネルとディスクが書き込みストリームにつきっきりになりかねず、読み取りに悪影響をおよぼすことも**
- **仮にスケジューラが”常に”ブロックをソートして処理していれば、遠いブロックがいつまでも読めず**、読み取りレイテンシ的にまずい
	- 初期のめちゃ単純な対策は **Linusエレベータ**
	- **一定時間以上残っているI/O要求はソートせずにキューへ追加**
- **Deadline I/O スケジューラ**
	- **エレベータをもう少しシステマティックに賢く実装**
	- **I/O要求キューに加えて、読み取りFIFOキューと書き込みFIFOキューを追加** して情報を記録・管理
	- 要求を発行順序でソート、制限時間を設定
	- **読み取りの方に短い持間を設定して、書き込みストリームにつきっきり状態を回避**
	- 制限時間がすぎてもキューの先頭要求が処理されなければ、スケジューラは処理を一時中断してFIFOキューの要求を処理する
	- スループット向上の為、同じFIFOキューにあるI/O要求もいくつか続けて処理
	- 結果として、どのI/O要求も「異常に長く時間がかかる」という事態は避けられる
- **Anticipatory I/Oスケジューラ**
	- **Deadline + 読み取りのディスパッチ要求があったときに少し待つ**
	- 今いる位置に近いところが次に要求されるだろうと“予測”して待つ
	- 大半の読み取り処理はディスク上で前後に依存関係をもつので、「予測して待ったことが無駄になる」という心配はない
- **CFQ (Complete Fair Queuing) I/O スケジューラ**
	- **バランス良い、おすすめ**
	- **プロセスごとに独自のキュー（タイムスライスつき）を用意して、各プロセスのキューをラウンドロビンで処理** していく
	- **キューの処理（タイムスライス消費or要求なしになるまで）→要求なしなら、次の要求を予測してそのキューで少し待つ→次のプロセスのキューへ**
	- **シンクロナイズドI/Oに高い優先度を割り当てることで、Writeにつきっきり問題を回避**
- **Noop I/O スケジューラ**
	- ソートは考えない、**マージだけする**
- **ディスクI/Oはシステムの中でも際立って遅い！ので、I/Oパフォーマンスを最大限に引き出していこう**
	- I/O処理のマージで処理数を最小化
	- I/Oのブロックサイズでのアラインメント
	- ユーザ空間バッファリング
	- ベクタI/O、位置指定I/O、非同期I/Oなど、高度なI/O処理で効率化
- カーネル側ではスケジューラでディスクシークを抑えている。アプリケーション我でできることは？
	- **I/O要求のマージ＆ソートをアプリケーションで独自にやることも可能**
		- **スケジューラがソートできる要求の数は限られているので、必ずしも連続した大量のI/Oすべてをキュー内で最適に処理できるわけではない**
		- **ならアプリ側でそこをきちんとやって渡してあげればよい**
	- アプリ側での要求ソートは **パス名、inode番号、物理ディスクブロック番号** を参照しながら行う
		- パス名
			- 大まかなソートとして有意義、実装しやすい
			- 同じディレクトリのファイルはディスク上でも隣接しやすい
			- ただしあくまで近似的なソートなので完璧ではないし、フラグメンテーションが進んでいればソートの効果は低くなる
		- inode番号
			- **一番多く利用されている**
			- inodeはすべてのファイルに対応してメタデータを格納していて、一意な番号をもつ
			- 一般に、物理ブロックで先にくるファイルはinode番号も若いので、これについてソートするのはパス名ソートより賢い
			- とはいえ、やっぱりフラグメンテーションでは精度が下がる
		- 物理ディスクブロック番号
			- ファイルシステム内の論理ブロック番号から物理ブロック番号を特定できる
			- stat()で使用している論理ブロック数入手→各論理ブロックごとにioctl()で対応する物理ブロック番号入手
			- 先頭の論理ブロックだけをキーにソートすることも可能
			- root権限が必須
			- 理想的なソートだけど、はじめに取り組む手法として最善とはいえない